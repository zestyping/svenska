#!/usr/bin/env python

import csv
import re
import sys

def fix_note(sv, en, tags):
    if sv.startswith('"') and sv.endswith('"'):
        sv = sv.strip('"')
    match = re.search(r'^(.*),&quot;(.*?)(&quot;)?\s*$', sv)
    if match and not en.strip():
        sv = match.group(1)
        en = match.group(2)
    sv, tags = fix_sv(sv, tags)
    en, tags = fix_en(en, tags)
    if ' .: ' in sv:
        tags = tags.replace('mass', '')
    tags = norm_tags(tags)
    return sv, en, tags

def remove_html(html):
    return re.sub(r'<[^>]*>', '', html)

def norm_tags(tags):
    return ' '.join(sorted(tags.split()))

def has(tags, tag):
    return tag in tags.split()

def split_pos(text, tags):
    new_tags = set()
    while True:
        match = re.search(r'\((adj|adv|conj|dir|mass|n|num|phr|pn|pos|prep|s|v)\)', text)
        if match:
            part = match.group(1)
            if part in ['dir', 'pos']:  # direction and position words are adverbs
                part = 'adv'
            new_tags.add(part)
            text = text[:match.start()] + ' ' + text[match.end():]
            text = ' '.join(text.split()).strip()
        else:
            break
    if new_tags:
        return text, ' '.join(sorted(new_tags))
    return text, tags

def possible_definite_forms(base):
    last = base[-1]
    if last in 'aeiouäåö':
        yield base + 'n'
    if last in 'mnp':
        yield base + last + 'en'
    yield base + 'en'
    if base[-2:] in ['el', 'en', 'er']:
        yield base[:-2] + last + 'et'
    if last in 'aeiouäåö':
        yield base + 't'
    if last in 'mnp':
        yield base + last + 'et'
    yield base + 'et'

def fix_sv(sv, tags):
    sv = sv.strip()
    if sv.startswith('<br>'):
        sv = sv[4:]
    if '<br>' in sv:
        first, rest = sv.split('<br>', 1)
        sv, tags = fix_sv(first, tags)
        return sv + '<br>' + rest, tags
    if sv.split()[0] in ['How', 'What', 'Whats', 'Which', 'When', 'Where', 'Translate', 'Plural', 'Preteritum:', 'Pronouns:', 'Då-adverb']:
        return sv, 'q'
    if sv.split()[:2] in [['Object', 'pronouns:'], ['Possessive', 'pronouns:'], ['Verb', 'groups:'], ['Give', 'two'], ['In', 'what'], ['Default', 'ending']]:
        return sv, 'q'
    if sv.split().count('...') == 1:
        sv = sv.replace('...', 'X')
    sv, tags = split_pos(sv, tags)
    if sv.startswith('*'):
        return sv[1:], tags
    match = re.search(r'^([^(]+) \(([^,)]+(, [^,)]+)*)\)\s*$', sv)
    if match:
        base = match.group(1)
        forms = re.split(r', *', match.group(2))
        while forms[-1] == '-':
            forms.pop()
        [f1, f2, f3] = (forms + ['', ''])[:3]
        if len(forms) == 1 and (has(tags, 'n') or f1 in [
            base + 'n', base + 't', base + 'en', base + 'et', base + 'na',
            base[:-2] + base[-1] + 'en', base[:-2] + base[-1] + 'et',
            '-n', '-t', '-en', '-et'
        ]):
            # noun with definite form only
            if f1.startswith('-'):
                f1 = base + f1[1:]
            article = 'ett' if f1.endswith('t') else 'en'
            return f'<span class="{article}">{base} [{f1}]</span>', 'mass n'

        if len(forms) == 3 and (has(tags, 'n') or
            f3.endswith('rna') or
            f2 in [base, '-'] or
            f1 in ['-n', '-t', '-en', '-et'] or
            f1.endswith(':en') or f1.endswith(':et') or
            f1 in possible_definite_forms(base)
        ):
            # noun with definite, plural, and definite plural forms
            base = re.sub(r'^(en|ett) ', '', base)
            article = 'ett' if f1.endswith('t') else 'en'
            if f1.startswith('-'):
                f1 = base + f1[1:]
            if f2 in ['-', '--', '–']:
                f2 = base
            elif f2.startswith('-'):
                f2 = base + f2[1:]
            if f3.startswith('-'):
                f3 = base + f3[1:]
            return f'<span class="{article}">{article} {base} [{f1}] .: {f2} [{f3}]</span>', 'count n'

        if len(forms) == 1 and (has(tags, 'adj') or f1 == '-a'):
            # adjective with plural form
            if f1.startswith('-'):
                f1 = base + f1[1:]
            return f'{base} .: {f1}', 'adj'
        if len(forms) == 2 and (has(tags, 'adj') or
            f1.endswith('t') or f2.endswith('a')
        ):
            if f1.startswith('-'):
                f1 = base + f1[1:]
            if f2.startswith('-'):
                f2 = base + f2[1:]
            # adjective with ett and plural forms
            return f'<span class="en">{base}</span> / <span class="ett">{f1}</span> .: {f2}', 'adj'

        if len(forms) == 3 and (has(tags, 'v') or f2 != f3):
            # verb with present, preteritum, and pluperfect forms
            base = re.sub(r'^(att )*', '', base)
            f3 = re.sub(r'^(har )*', '', f3)
            return f'att {base} ({f1}, {f2}, har {f3})', 'v'

    if not tags:
        if re.match(r'^[A-ZÄÅÖ][a-zäåö]+.*[.!?]$', sv):
            return sv, 's'
        if re.search(r'^"?[A-ZÄÅÖ][^ ]+ +[a-zäåö]', sv) and len(sv.split()) > 2:
            return sv, 's'
        if re.match(r'^gå [a-zäåö]+ [a-zäåö]', sv):
            return sv, 'phr'
        if re.search(r'\b(för|förra|hela|i|inte|på) [a-zäåö]', sv):
            return sv, 'phr'
        if 'X' in sv.split():
            return sv, 'phr'
    if re.search(r'.* \[.*\] => .* \[.*\]', sv):
        return sv.replace('=>', '.:'), 'n'
    first = sv.split()[0]
    if 'num' not in tags and 'phr' not in tags and first in ['en', 'ett']:
        return f'<span class="{first}">{sv}</span>', 'count n'
    if re.match(r'^[A-ZÄÅÖ][a-zäåö]+$', sv):
        return sv, 'mass n'
    if re.search(r'.* / .* => .*', sv):
        return sv.replace('=>', '.:'), 'adj'
    if sv.startswith('att '):
        return sv, 'v'
    if re.search(r'^"?[A-ZÄÅÖ]', sv) and len(sv.split()) > 1:
        return sv, 's'
    return sv, tags

def fix_en(en, tags):
    if '<br>' in en:
        first, rest = en.split('<br>', 1)
        return fix_en(first, tags) + '<br>' + rest, tags
    _, tags = split_pos(en, tags)
    if en.startswith('*'):
        return en[1:], tags
    if en.split().count('...') == 1:
        en = en.replace('...', 'X')
    if has(tags, 'v'):
        return 'to ' + re.sub('^(to )*', '', en), tags
    if has(tags, 'n'):
        if has(tags, 'count'):
            if en.split()[0] not in ['a', 'an']:
                en = 'an ' + en if en[0].lower() in 'aeiou' else 'a ' + en
        elif en.split()[0].lower() == 'the':
            return en, 'mass n'
    if not tags and en.split()[0].lower() == 'the':
        return en, 'mass n'
    return en, tags

def find_cols(count, directives, sides):
    cols = [''] * count
    for directive in directives:
        match = re.search(r'^#(\w+) column:(\d+)', directive)
        if match:
            cols[int(match.group(2)) - 1] = match.group(1)
    sides = sides[:]
    for i, col in enumerate(cols):
        if not col:
            cols[i] = sides.pop(0)
        if not sides:
            break
    return cols

def clean(value):
    value = value.strip()
    value = re.sub(r'^<i>(.*)</i>$', r'\1', value)
    value = value.replace('–', '-')
    value = value.replace('“', '"')
    value = value.replace('”', '"')
    value = value.replace("’", "'")
    value = value.replace('‥', '..')
    value = value.replace('…', '...')
    if value.startswith('"') and value.endswith('"'):
        value = value[1:-1]
    return value.strip()

def generate_guid(sv, tags):
    prefix = tags or 'u'
    prefix = (' ' + prefix + ' ').replace(' mass ', ' ').replace(' count ', ' ')
    prefix = prefix.strip()
    text = sv.lower().replace('ä', 'ae').replace('å', 'aa').replace('ö', 'oe')
    text = text.replace('é', 'e')
    text = text.replace('...', 'x')
    text = re.sub(r'\(.*\)', '', text)
    text = re.sub(r'\[.*\]', '', text)
    text = re.sub(r'[ /-]+', ' ', text)
    text = re.sub(r'[^a-z0-9 ]', '', text)
    if prefix == 'n':
        text = re.sub(r'^en |^ett ', '', text)
    if prefix == 'v':
        text = re.sub(r'^att ', '', text)
    words = text.split()
    if len(words) > 1:
        i = 0
        while len('_'.join(words[:i])) < 14 and i < len(words): i += 1
        ident = '_'.join(words[:i])[:15]
        if ident[-2] != '_': ident += '_'
        ident += ''.join(word[0] for word in words[i:])
    else:
        ident = text[:15]
    return prefix + '_' + ident.strip('_').strip()

def fix(infile, outfile, sides=['sv', 'en']):
    lines = infile.readlines()
    directives = [line for line in lines if line.startswith('#')]
    notes = [line for line in lines if not line.startswith('#')]
    if directives and any('column:' in d for d in directives):
        delim = '\t'
        cols = find_cols(len(notes[0].split(delim)), directives, sides)
    else:
        delim = ','
        cols = sides
    records = []
    for values in csv.reader(notes, delimiter=delim):
        if not values:
            continue
        if len(values) < len(cols):
            sys.stderr.write('Missing columns: %r\n' % values)
            continue
        fields = {col: values[i] for i, col in enumerate(cols)}
        if 'sv' in fields and 'en' in fields:
            sv_lines = fields.pop('sv').split('<br>')
            en_lines = fields.pop('en').split('<br>')
            if len(sv_lines) == len(en_lines):
                for sv, en in zip(sv_lines, en_lines):
                    records.append(dict(fields, sv=clean(sv), en=clean(en)))
    seen = set()
    fixed = {}
    en_tags = {}
    en_guids = {}

    for record in records:
        tags = record.get('tags', '')
        sv, en, tags = fix_note(record['sv'], record['en'], tags)
        guid = record.get('guid', generate_guid(record['sv'], tags))
        if len(sv.split()) == 1 and sv.capitalize() == sv and sv == en:
            # skip proper nouns that are identical in Swedish and English
            continue
        fixed[guid] = {'guid': guid, 'sv': sv, 'en': en, 'tags': tags}
        en_key = re.sub(r'\([^)]*\)', '', en.split('/')[0]).strip()
        if tags:
            en_tags.setdefault(en_key, set()).add(tags)
        en_guids.setdefault(en_key, set()).add(guid)

    for en_key in en_guids:
        if len(en_guids[en_key]) > 1:
            # remove untagged English duplicates
            for guid in en_guids[en_key]:
                if guid.startswith('u_') and guid in fixed:
                    del fixed[guid]

    tagged_guids = {}
    for guid in fixed:
        guid_key = re.sub(r'^.*?_', '', guid)
        tagged_guids.setdefault(guid_key, set()).add(guid)

    for guid_key in tagged_guids:
        if len(tagged_guids[guid_key]) > 1:
            # remove untagged guid duplicates
            if 'u_' + guid_key in fixed:
                del fixed['u_' + guid_key]

    records_by_en_key = {}

    for record in fixed.values():
        en_key = re.sub(r'\([^)]*\)', '', record['en'].split('/')[0]).strip()
        records_by_en_key.setdefault(en_key, []).append(record)
        if len(en_tags.get(en_key, set())) > 1:
            # add part-of-speeeh tag to disambiguate identical English words
            _, tags = split_pos(record['en'], '')
            if record['tags'] not in tags:
                record['en'] += f' ({record["tags"]})'

    dups = [k for k in records_by_en_key if len(records_by_en_key[k]) > 1]
    for en_key in sorted(dups):
        records = records_by_en_key[en_key]
        sys.stderr.write('"%s" has %d translations:\n' % (records[0]['en'], len(records)))
        for sv, en in sorted((record['sv'], record['en']) for record in records):
            sys.stderr.write('    %s = %s\n' % (remove_html(sv), en))

    outfile.write('#html:true\n')
    outfile.write('#separator:tab\n')
    outfile.write('#guid column:1\n')
    outfile.write('#tags column:2\n')
    for n in sorted(fixed.values(), key=lambda n: n['guid']):
        n['sv'] = '<div class="sv">' + n['sv'] + '</div>'
        fields = [n['guid'], n['tags']] + [n[col] for col in sides]
        outfile.write('\t'.join(fields) + '\n')

if __name__ == '__main__':
    args = sys.argv[1:]
    infile = sys.stdin
    outfile = sys.stdout
    if len(args) >= 1:
        infile = open(args[0])
    if len(args) >= 2:
        outfile = open(args[0], 'w')
    fix(infile, outfile)
